---
## Front matter
title: "Отчет по выполнению внешнего курса"
author: "Виеру Женифер"

## Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

## Pdf output format
toc: true # Table of contents
toc-depth: 2
lof: true # List of figures
lot: true # List of tables
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n polyglossia
polyglossia-lang:
  name: russian
  options:
	- spelling=modern
	- babelshorthands=true
polyglossia-otherlangs:
  name: english
## I18n babel
babel-lang: russian
babel-otherlangs: english
## Fonts
mainfont: IBM Plex Serif
romanfont: IBM Plex Serif
sansfont: IBM Plex Sans
monofont: IBM Plex Mono
mathfont: STIX Two Math
mainfontoptions: Ligatures=Common,Ligatures=TeX,Scale=0.94
romanfontoptions: Ligatures=Common,Ligatures=TeX,Scale=0.94
sansfontoptions: Ligatures=Common,Ligatures=TeX,Scale=MatchLowercase,Scale=0.94
monofontoptions: Scale=MatchLowercase,Scale=0.94,FakeStretch=0.9
mathfontoptions:
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
## Pandoc-crossref LaTeX customization
figureTitle: "Рис."
tableTitle: "Таблица"
listingTitle: "Листинг"
lofTitle: "Список иллюстраций"
lotTitle: "Список таблиц"
lolTitle: "Листинги"
## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---

# Цель работы

Цель выполнения данного курса заключается в том, чтобы узнать больше о Линуксе и лучше разбираться в терминале, серверах и скриптах.


# Выполнение внешнего курса

#  Продвинутые темы

Я открыла файл и чтобы сразу выйти из редактора я нажала " : ", затем "q", затем "Еnter".Из-за этого я выбрала этот вариант (рис. [-@fig:001]).

![Задание 3.1.1](image/3.1.-1.png){#fig:001 width=70%}

Разница между word (w, e, b) и WORD (W, E, B) в vim заключается в том, как они определяют границы слова:word: Считает словом последовательность букв, цифр и символа подчеркивания _. Другие символы (пробелы, знаки препинания) считаются разделителями. WORD: Считает словом любую последовательность не-пробельных символов.Из-за этого я выбрала этот вариант (рис. [-@fig:002]).

![Задание 3.1.2](image/3.1.-2.png){#fig:002 width=70%}

Я знаю, чтто :g/Windows/: Эта часть команды grep-подобным образом находит все* строки, содержащие слово "Windows".s/Windows/Linux/: Для каждой найденной строки (:g/Windows/ вызывает эту замену для каждой строки), эта часть выполняет замену только первого вхождения "Windows" на "Linux". Флаг g (глобальная замена) здесь не используется намеренно, чтобы заменить только первое вхождение.Из-за этого я написала этот вариант (рис. [-@fig:003]).

![Задание 3.1.3](image/3.1.-3.png){#fig:003 width=70%}

*  -- VISUAL --: В режиме выделения внизу редактора отображается надпись -- VISUAL -- (или ее локализованный вариант).
•  v (из нормального режима): Режим выделения активируется из нормального режима нажатием клавиши v.
•  d и y: В режиме выделения можно использовать команды d (удалить выделенное) и y (скопировать выделенное).
Поэтому я выбрала все подходящие варианты(рис. [-@fig:004]).

![Задание 3.1.4](image/3.1.-4.png){#fig:004 width=70%}

История команд сохраняется отдельно для каждой оболочки. Когда вы запускаете новую оболочку, она имеет свою собственную историю команд, которая изначально пуста (или может быть загружена из файла истории, но это отдельная история).Из-за этого я написала этот вариант (рис. [-@fig:005]).

![Задание 3.2.1](image/3.2.-1.png){#fig:005 width=70%}

Я нахилась в директории /home/bi/Documents/ и запускала в ней скрипт следующего содержания:#!/bin/bash cd /home/bi/ touch file1.txt cd /home/bi/Desktop/. В итоге я оказалась /home/bi/file1.txt.Из-за этого я написала этот вариант(рис. [-@fig:006]).

![Задание 3.2.2](image/3.2.-2.png){#fig:006 width=70%}

В bash имена переменных должны начинаться с буквы или символа подчеркивания (_) и могут содержать буквы, цифры и символ подчеркивания.

•  var.i.able, var@iable, vari/able, var-i-able, variab$$le: Недопустимые символы (., @, /, -, $).
•  123variable: Начинается с цифры (недопустимо).
•  _variable: Допустимое имя переменной.(рис. [-@fig:007]).

![Задание 3.2.3](image/3.2.-3.png){#fig:007 width=70%}

Я изучила скрипт и по нему написала данную програму. (рис. [-@fig:008]).

![Задание 3.2.4](image/3.2.-4.png){#fig:008 width=70%}

•  -e $0: -e проверяет, существует ли файл. $0 - имя запущенного скрипта. Скрипт, очевидно, существует, когда он запущен. Значит, это условие всегда истинно.
•  ! (4 -le 3): 4 -le 3 - "4 меньше или равно 3" - ложно. ! инвертирует ложь в истину. Условие всегда истинно.
Таким образом, верны только -e $0 и ! (4 -le 3).(рис. [-@fig:009]).

![Задание 3.3.1](image/3.3.-1.png){#fig:009 width=70%}

Я написала этот скрипт и потучила ответ, на базе которого я выбрала ответ.(рис. [-@fig:010]).

![Задание 3.3.2](image/3.3.-2.png){#fig:010 width=70%}

Написала скрипт на базе полученных до данного момента знания. (рис. [-@fig:011]).

[Задание 3.3.3](image/3.3.-3.png){#fig:011 width=70%}

Я запустила этот скрипт и получила 5 раз "start" и 4 раза "finish".Из-за этого я написала этот вариант (рис. [-@fig:012]).

![Задание 3.3.4](image/3.3.-4.png){#fig:012 width=70%}

Написала скрипт на базе полученных до данного момента знания.(рис. [-@fig:013]).

![Задание 3.3.5](image/3.3.-5.png){#fig:013 width=70%}

•  let "a=$a+$b": Внутри кавычек переменные должны использоваться без $. Правильно let "a=$a+$b". Инструкция верна.
•  let "a+=b": let выполняет арифметические вычисления. a+=b - корректная запись для сложения b с a и сохранения результата в a. Кавычки позволяют использовать переменные без $. Инструкция верна.
Из-за этого я написала этот вариант(рис. [-@fig:014]).

![Задание 3.4.1](image/3.4.-1.png){#fig:014 width=70%}

Находясь в директории /home/bi/Documents/ и запустив в ней скрипт следующего содержания:

#!/bin/bash

cd /home/bi/
echo "`pwd`"
При выполнения echo я получила ответ /home/bi. Из-за этого я написала этот вариант(рис. [-@fig:015]).

![Задание 3.4.2](image/3.4.-2.png){#fig:015 width=70%}

*  if [[ program -eq 0 ]]: Неправильно. program выполнится, но [[ ... ]] получит ее вывод, а не код возврата.
•  Сначала var=\program\, затем if [[ $var -eq 0 ]]: Неправильно. В $var попадет вывод program, а не код возврата.
•  Сначала запустить program, затем if [[ $? -eq 0 ]]: Правильно. $? содержит код возврата последней выполненной команды.
•  if program > some_file.txt: Правильно. Перенаправление вывода не мешает if получить код возврата program.
Вывод: верны последние два варианта.(рис. [-@fig:016]).

![Задание 3.4.3](image/3.4.-3.png){#fig:016 width=70%}

•  c1 будет последовательно увеличиваться на 1, 2, 3, ..., 10. Сумма чисел от 1 до 10 равна (1+10)*10/2 = 55.

•  c2 будет последовательно увеличиваться на 12, 22, 32, ..., 102, то есть 2, 4, 6, ..., 20. Это то же самое, что удвоенная сумма чисел от 1 до 10, то есть 55 * 2 = 110.

Однако, из-за того, что переменные изначально пустые, в c1 будет просто накапливаться сумма. А в c2 будет накапливаться сумма, но поскольку используется операция +=, к пустой строке будут добавляться результаты умножения, пока не получится число.

Следовательно, вывод будет: counters are 55 and 110(рис. [-@fig:017]).

![Задание 3.4.4](image/3.4.-4.png){#fig:017 width=70%}

Написала скрипт на базе полученных до данного момента знания.(рис. [-@fig:018]).

![Задание 3.4.5](image/3.4.-5.png){#fig:018 width=70%}

Написала скрипт на базе полученных до данного момента знания.(рис. [-@fig:019]).

![Задание 3.4.6](image/3.4.-6.png){#fig:019 width=70%}

Файлы, которые найдет -iname, но не найдет -name, это те, имена которых начинаются с "Star" или "STAR" и т.д., но не с "star":

•   Star_Wars.avi
•   STARS.txt(рис. [-@fig:020]).

![Задание 3.5.1](image/3.5.-1.png){#fig:020 width=70%}

1. "-path" учитывает путь, а "-name" только имя файла". Это значит, что если -path требует совпадения части пути, а -name только имени, то -name может найти больше. Пример: find . -name "file" найдет a/file и b/file, а find . -path "*b/file" найдет только b/file. Значит первый пункт верный.

2. "-path" регистрозависим.

3. "Результат иногда остается тем же". Да, если шаблон -path соответствует только имени файла, результат будет такой же, как у -name. Например: find . -name "file" и find . -path "./file" выдадут (во многих случаях) одинаковый результат. Значит третий пункт верный.

4. -name и -path не всегда работают одинаково, так как -path сопоставляет путь, а -name только имя.

5. -path и -name можно использовать для поиска как файлов, так и директорий.(рис. [-@fig:021]).

![Задание 3.5.2](image/3.5.-2.png){#fig:021 width=70%}

*  find /home/bi: Начинает поиск в директории /home/bi.
•  -mindepth 2: Начинает поиск с глубины 2 (то есть, не ищет в самой /home/bi).
•  -maxdepth 3: Заканчивает поиск на глубине 3.
•  -name "file*": Ищет файлы, имена которых начинаются с "file".

Теперь разберем глубину каждого файла:

•  file1: Находится на глубине 2 (/home/bi/dir1/file1).
•  file2: Находится на глубине 3 (/home/bi/dir1/dir2/file2).
•  file3: Находится на глубине 4 (/home/bi/dir1/dir2/dir3/file3).

Поскольку -mindepth 2 и -maxdepth 3, будут найдены только file1 и file2. file3 находится слишком глубоко.

Таким образом, ответ: Все кроме file3(рис. [-@fig:022]).

![Задание 3.5.3](image/3.5.-3.png){#fig:022 width=70%}

Файл results.txt каждый раз перезаписывается, поэтому, в конечном итоге, его размер будет определяться только последней выполненной командой grep. Независимо от того, какая команда выполнялась последней, размер файла будет определяться выводом этой команды. Следовательно, файл results.txt будет одинакового размера во всех случаях, потому что его содержимое перезаписывается.(рис. [-@fig:023]).

![Задание 3.5.4](image/3.5.-4.png){#fig:023 width=70%}

grep ищет строки, которые заканчиваются на Ubuntu или ubuntu и перед этим (необязательно) имеют одну букву x, k, l (или заглавные X, K, L). Все строки в списке подходят.(рис. [-@fig:024]).

![Задание 3.5.5](image/3.5.-5.png){#fig:024 width=70%}

Я выбрала "Каждая строчка будет выведена два раза" так как без -n, sed по умолчанию выводит каждую строку. /pattern/p тоже выводит строки, соответствующие pattern. Значит, подходящие строки будут выведены дважды.(рис. [-@fig:025]).

![Задание 3.5.6](image/3.5.-6.png){#fig:025 width=70%}

Из првктики знаю, что при запуске gnuplot, чтобы при его закрытии не были автоматически закрыты и все нарисованные в нём графики нужно указать 
-p, --persist(рис. [-@fig:026]).

![Задание 3.6.1](image/3.6.-1.png){#fig:026 width=70%}

• set key autotitle columnhead: Эта команда сообщает gnuplot, что названия для графиков нужно брать из заголовков столбцов. НО у тебя в файле нет заголовков, а значит он возьмет первое значение второго столбца
•  plot 'data.csv' using 1:2: Эта команда говорит gnuplot нарисовать график, используя первый столбец как X-координаты, а второй столбец как Y-координаты. Т.к. заголовков нет, первая строка рассматривается как данные, и точка из нее не будет нарисована. Останется 9 строк с данными.(рис. [-@fig:027]).

![Задание 2.6.2](image/3.6.-2.png){#fig:027 width=70%}

•  chmod ug+w file.txt; chmod u+x file.txt: Добавляет запись пользователю и группе, затем исполнение пользователю.
•  chmod a+wx file.txt; chmod o-wx file.txt; chmod g-x file.txt: Добавляет запись и исполнение всем, потом убирает запись и исполнение у "others", потом убирает исполнение у группы. (рис. [-@fig:028]).

![Задание 3.7.1](image/3.7.-1.png){#fig:028 width=70%}

•  sudo chmod a+w dir: Даёт право записи всем, включая user.
•  sudo chown user:group dir: Делает user владельцем, давая ему права владельца, т.е. запись.(рис. [-@fig:029]).

![Задание 3.7.2](image/3.7.-2.png){#fig:029 width=70%}

После просмотра видео, я узнала, что с использованием команды wc можно посчитать количество символов, длину самой длинной строки, количество слов(рис. [-@fig:030]).

![Задание 2.7.3](image/3.7.-3.png){#fig:030 width=70%}

# Выводы

При выполнении данного курса я научилась как установить Линукс, совершать обмен файлами и запускать приложения. Дальше я изучала текстовы	редактор vim и узнала как работать с разными скриптами. 


